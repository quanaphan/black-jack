#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('black-jack:server');
var http = require('http');
const cookie = require('cookie');
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Create Socket.IO on server
 */
var io = require('socket.io')(server);

/***************************************************************************************************
 * Socket logics
 */
// config + init
var game_sessions = {};
var player_sessions = {};
//var session_deck = {};
//need a player list of sort here
var cards = require('../utilities/cards');
var database = require('../database/db.js');
const max_session_capacity = 3;
var session_capacity = 4;
const cap_increment = 4;
const lobby = io.of('/lobby');
const game = io.of('/game');
const login = io.of('/login');
const account = io.of('/account');
/**
 * Utitlities for game_sessions
 */
/**
 * Populate game session from start to end
 */
var populate_game_sessions = function(start,end){
  for(i = start; i <= end; i++){
    var key = i;
    game_sessions[key] = {};
    game_sessions[key]['host'] = "";
    game_sessions[key]['title'] = "";
    game_sessions[key]['players'] = {};
    game_sessions[key]['dealer'] = {};
    game_sessions[key]['dealer']['hand'] = [];
    game_sessions[key]['active'] = false;
    game_sessions[key]['capacity'] = 0;
    game_sessions[key]['id'] = key;
  }
}

//init game session, starts from 1
populate_game_sessions(0, session_capacity);


/**
 * Reset session
 */
var reset_session = function(session){
    session['host'] = "";
    session['title'] = "";
    session['players'] = {};
    session['dealer']['hand'] = [];
    session['active'] = false;
    session['capacity'] = 0;
}

/**
 * Get next avail game session
 */
var avail_session = function(){
  for (var i = 0; i <= session_capacity; i++) {
    if(!game_sessions[i]['active']){
      //if game session is avail, return the session key/id
      return i;
    }
  }
  //fail to find an available session, all session busy
  //creating new session
  populate_game_sessions(session_capacity+1,session_capacity + cap_increment);
  var id = session_capacity+1;
  session_capacity += cap_increment;
  return id;
}

/**
 * Create a game session
 */
var create_session = function(id, title, username){
  game_sessions[id]['host'] = username;
  game_sessions[id]['title'] = title;
  game_sessions[id]['turn'] = 'p1';
  game_sessions[id]['active'] = true;
  game_sessions[id]['deck'] = [...cards];
}

/**
 * shuffle deck of given game session
 */
var shuffle_deck = function(id){
  game_sessions[id]['deck'] = shuffle(game_sessions[id]['deck']);
}    

/**
 * Utitlities for player_sessions
 */
/**
 * Create a new user under requested name
 * return true on success, return false on failure
 */
var load_user = function(key, cb){
  player_sessions[key] = {};
  player_sessions[key]['username'] = key;
  // load nickname from DB
  database.getUserInfo(key, function(result){
    player_sessions[key]['nickname'] = result.nickname;
    player_sessions[key]['balance'] = result.balance;
    player_sessions[key]['wins'] = result.wins;
    player_sessions[key]['loses'] = result.loses
    cb(); 
  });
}

var update_nick = function(key, nickname, cb){
  database.setUserNickname(key, nickname, cb());
  player_sessions[key]['nickname'] =  nickname;
}

var update_balance = function(key, balance, cb){
  database.setUserBalance(key, balance, cb());
  player_sessions[key]['balance'] = balance;
}


/***************************************************************************************************
 * Login socket logics
 */
login.on('connection', function(socket){
  console.log(socket.id + ' connected')
  // if has cookies
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie = cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        //add to player list & redirect
        // redirect to lobby
        socket.emit('login success');
      }
    }
  }

  socket.on('login', function(username, password){
    var validate = database.validateUser;
    var result;
    validate(username, password, function(result){
      console.log('result = ' + result);
      if (result){
        // success, load user from DB and emit success msg
        console.log('login success');
        socket.emit('login success');
        
      } else{
        // failed, emit failure msg
        console.log('login failure');
        socket.emit('login failure');
      }
    })
  })

  socket.on('create account', function(username, nickname, password){
    database.addUser(username, password, nickname, function(){
      console.log('login success');
      socket.emit('login success');
    }, function(){
      // failed, emit failure msg
      console.log('login failure');
      socket.emit('login failure');
    })
  })
})

/***************************************************************************************************
 * Lobby socket logics
 */
lobby.on('connection', function(socket){
  //should have credentials
  var username = '';
  console.log(socket.handshake.headers.cookie);
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie = cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        username = socket_cookie['username'];
        console.log("user connected to lobby is '" + username + "'");
        load_user(username, function(){
          console.log('Finished loading users. spamming emits')
          console.log('username = ' + username)
          socket.emit('init', JSON.stringify(player_sessions[username]));
        });  
        // send out game lobby list
        socket.emit('lobby update', JSON.stringify(game_sessions));
        database.getTopUsers(function(result){
          // send out leaderboard
          socket.emit('leaderboard', JSON.stringify(result));
        })
      }else{
        // failed to get cookie
        socket.emit('redirect to login');
      }
    }else{
      // failed to get cookie
      socket.emit('redirect to login');
    }
  }else{
    // failed to get cookie
    socket.emit('redirect to login');
  }

  console.log('connected');

  //requesting a lobby list refresh
  socket.on('refresh', function(){
    socket.emit('lobby update', JSON.stringify(game_sessions));
  })

  //request to create a room
  socket.on('create room', function(title){
    var id = avail_session();
    //Fill metadata
    create_session(id,title,username);
    // send ack, refresh lobby list
    socket.emit('create success', id);
    lobby.emit('lobby update', JSON.stringify(game_sessions));
  })

  //requesting to join a room
  socket.on('join room', function(id){
    //check if room is not full
    if(game_sessions[id]['capacity'] != max_session_capacity){
      //increase capacity
      game_sessions[id]['capacity'] += 1;
      // init metadata
      game_sessions[id]['players'][username] = {};
      game_sessions[id]['players'][username]['username'] = username;
      game_sessions[id]['players'][username]['nickname'] = player_sessions[username]['nickname'];
      game_sessions[id]['players'][username]['hand'] = [];
      var p = 'p' + game_sessions[id]['capacity'];
      game_sessions[id][p] = username;
      console.log("Joining room, current sessions: " + JSON.stringify(game_sessions, null, 2));
      player_sessions[username]['in-game'] = id;      
      //send ack, refresh lobby list
      lobby.emit('lobby update', JSON.stringify(game_sessions));
      socket.emit('join success')
    }else{
      //room is full
      socket.emit('join fail');
    }
  })

  socket.on('disconenct', function(){
    // do something
    console.log('disconnect from lobby by ' + username);
  })
})

/***************************************************************************************************
 * Profile/account socket logics
 */
account.on('connection', function(socket){
  var username = '';
  console.log(socket.handshake.headers.cookie);
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie = cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        username = socket_cookie['username'];
        load_user(username, function(){
          socket.emit('init', JSON.stringify(player_sessions[username]));
          database.getTopUsers(function(result){
            // send out leaderboard
            socket.emit('rankings', JSON.stringify(result));
          })
        });
      }else{
        // failed to get cookie
        socket.emit('redirect to login');
      }
    }else{
      // failed to get cookie
      socket.emit('redirect to login');
    }
  }else{
    // failed to get cookie
    socket.emit('redirect to login');
  }

  // more functionalities?

})

function nextPlayer(session){
  switch(session['turn']){
    case 'p1':
      // to player 2
      session['turn'] = 'p2';
      break;
    case 'p2':
      // to player 3
      session['turn'] = 'p3';
      break;
    case 'p3':
      // to dealer
      session['turn'] = 'dealer';
      break;
    case 'dealer':
      // to o1
      session['turn'] = 'p1';
      break;
  }
}

function dealCard(session){
  // get turn
  var turn = session['turn'];
  // if dealer's
  if(turn === 'dealer'){
    session['dealer']['hand'].push(session['deck'].pop());
  }else{ // if player's
    var username = session[turn];
    session['players'][username]['hand'].push(session['deck'].pop());
  }
}

function removeFromGame(session, username){
  console.log(session);
  console.log(username);
  // When capacity = 1
  if(session['capacity'] === 1){
    // reset session
    delete session['players'][username];
    delete session['p1'];
    delete session['deck'];
    reset_session(session)
  }else if(session['capacity'] === 2){
    // 2 players
    if(session['host'] === username){
      // if host is leaving, migrating.
      delete session['players'][username];
      session['host'] = session['p2'];
      session['p1'] = session['p2'];
      session['capacity'] = 1;
      delete session['p2'];
    }else{
      // not host
      delete session['players'][username];
      session['capacity'] = 1;
      delete session['p2'];
    }
  }else if(session['capacity'] === 3){
    // max - 3 players
    if(session['p1'] === username){
      // host leaving
      delete session['players'][username];
      session['host'] = session['p2'];
      session['p1'] = session['p2'];
      session['p2'] = session['p3'];
      session['capacity'] = 2;
      delete session['p3'];
    }else if(session['p2'] === username){
      // p2 leaving
      delete session['players'][username];
      session['p2'] = session['p3'];
      session['capacity'] = 2;
      delete session['p3'];
    }else {
      // p3 leaving
      delete session['players'][username];
      session['capacity'] = 2;
      delete session['p3'];
    }
  }
  // tell lobby to update list
  lobby.emit('lobby update', JSON.stringify(game_sessions));
}


/***************************************************************************************************
 * Game session logic
 */
game.on('connection', function(socket){
  var username = '';
  var sessionID = -1;
  var session = {};
  var channelname = '';
  // join game channel for broadcast
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie =  cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        username = socket_cookie['username'];
        sessionID = player_sessions[username]['in-game'];
        session = game_sessions[sessionID];
        channelname = "#" + sessionID;
        console.log('username = ' + username);
        console.log(session);
        socket.join(channelname);
        load_user(username, function(){
          socket.emit('init', JSON.stringify(player_sessions[username]), JSON.stringify(session))
        })
        // Shuffle, x3 in total since 3 players expected
        shuffle_deck(sessionID);
      }else{
        //redirect back to login
      }
    }else{
      //redirect back to login
    }
  }else{
    //redirect back to login
  }
  socket.on('disconnect', function(){
    // remove user from game session
    removeFromGame(session, username);
    // do more clean ups
    game.to(channelname).emit('player left', username, JSON.stringify(session));
  })
  // TODO - get nickname here
  
  /**
   * Gameflow:
   * Deck shuffled
   * Place bet & ready
   * distribute cards
   * p1 turn
   * p2 turn
   * p3 turn
   * dealer turn
   */
  /**
   * A turn has:
   * card deal
   * stay/pass
   * split
   */

  // ready to start
  socket.on('ready', function(betAmount){
    game.to(channelname).emit('lock in', username);
    session['players'][username]['bet'] = betAmount;
  });

  // when all bets are placed
  socket.on('card distribution request', function(){
    if(username === session['host']){//only the host can request
      // first distribution
      // loop through 2 whole cycles
      for (var i = 0; i < 8; i++) {
        dealCard(session);
        nextPlayer(session);
      }
      // tell all to play card distribution animation
      game.to(channelname).emit('init card distribution', JSON.stringify(session));
    }
  });

  // when card deal is requested
  socket.on('card deal', function(){
    dealCard(session);
    // card dealt, to user, new session info
    game.to(channelname).emit('card dealt', username, JSON.stringify(session));
  })

  // stay/pass
  socket.on('pass', function(){
    nextPlayer(session);
    // next player, new session
    game.to(channelname).emit('next player', JSON.stringify(session));
  })

  socket.on('split', function(){
  // do something for split
  // dunno this yet, have to think about it
  // have to consider 2x Aces scenarios
  })
  
  socket.on('chicken dinner', function(){
  // do sth on chicken dinner
  // to be considered later
  // have to check if dealer is also black-jack -> skip to endgame logic 
  // insurance bets, maibe?
  })

  // game end, total up
  socket.on('tally score', function(){
    if(username === session['host']){
      // only host can request a tally
      
      // dealer's turn
      // add dealer logics here
      var dealer = session['dealer'];
      var score = calculateHandWithAces(dealer['hand']);
      // if score is less than 17
      while(score < 17){
        // turn for be dealer's at this point, printing just in case
        console.log(session['turn']);
        // draw another card
        dealCard(session);
        // calc score again
        score = calculateHandWithAces(dealer['hand']);
        session['dealer']['score'] = score;
      }
      // done dealer's draws, emitting update
      game.to(channelname).emit('dealer drawn', JSON.stringify(session));
      // tally up players' hand
      const players = Object.keys(session['players']);
      for(var player of players){
        var score = calculateHandWithAces(session['players'][player][hand]);
        session['player'][player]['score'] = score;
      }
      // check against dealer score
      for(var player of players){
        // check for chicken dinner here - TODO

        // check if host has chicken dinner(?)
        // declare victory/defeat (spam emit on channel)
        if(session['player'][player]['score'] < session['dealer']['score']){
          // lost
          game.to(channelname).emit('lose', player);
        }else if (session['player'][player]['score'] === session['dealer']['score']){
          // draw
          game.to(channelname).emit('draw', player);
        }else{
          // win
          game.to(channelname).emit('win', player);
        }
        // TODO
        // also have to consider
        // Save balance to DB according to win/lose w/ placed bet
        // new deck + shuffle
      }
    }
  });
})

// not needed, probably
io.on('connection', function(socket){
  // On new socket connection
  socket.on('disconenct', function(){

  })
})








/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);


/**
 * calculateHandTotals
 *
 * calculates the the total value fo a hand: need ace logic
 *
 * */

function calculateHandTotals(hand) {
    let sum = 0;

    for (let i = 0; i < hand.length; i++) {
        sum += hand[i].value;
    }
    return sum;
}

/**
 * Returns boolean value if the hand contains an ace
 * @param hand
 * @returns {boolean}
 */

function hasUnreducedAce(hand) {

    for (let i = 0; i < hand.length; i++) {
        if ((hand[i].name === "ace") && (hand[i].value === 11)) {
            return true;
        } else {
            return false;
        }
    }
}

/**
 * finds the aces in the hand that has not already been reduced and sets its value to 1
 *
 * @param hand
 *
 */
function calculateHandWithAces(hand) {
    let total = calculateHandTotals(hand);

    while (hasUnreducedAce(hand) && total > 21) {
        for (let i = 0; i < hand.length; i++) {
            if (hand[i].name === "ace" && hand[i].value === 11) {
                hand[i].value = 1;

               break;
            }
        }
    total = calculateHandTotals(hand);
    }
}

/**
 * Generate random alphanumeric
 */
function randomString(length){
  var text = "";
  var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (var i = 0; i < length; i++) 
    text += possible.charAt(Math.floor(Math.random()*possible.length));
  return text;
}

/** Fisher-Yates shuffle algorithm
 * Shuffles array in place.
 * @param {Array} a items An array containing the items.
 */
function shuffle(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
