#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('black-jack:server');
var http = require('http');
const cookie = require('cookie');
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Create Socket.IO on server
 */
var io = require('socket.io')(server);

/***************************************************************************************************
 * Socket logics
 */
// config + init
var game_sessions = {};
var player_sessions = {};
//var session_deck = {};
//need a player list of sort here
var cards = require('../utilities/cards');
var database = require('../database/db.js');
const max_session_capacity = 3;
var session_capacity = 4;
const cap_increment = 4;
const lobby = io.of('/lobby');
const game = io.of('/game');
const login = io.of('/login');
const account = io.of('/account');
/**
 * Utitlities for game_sessions
 */
/**
 * Populate game session from start to end
 */
var populate_game_sessions = function(start,end){
  for(i = start; i <= end; i++){
    var key = i;
    game_sessions[key] = {};
    game_sessions[key]['host'] = "";
    game_sessions[key]['title'] = "";
    game_sessions[key]['players'] = {};
    game_sessions[key]['dealer'] = {};
    game_sessions[key]['dealer']['hand'] = [];
    game_sessions[key]['active'] = false;
    game_sessions[key]['in-match'] =  false;
    game_sessions[key]['capacity'] = 0;
    game_sessions[key]['id'] = key;
  }
}

//init game session, starts from 1
populate_game_sessions(0, session_capacity);


/**
 * Reset session
 */
var reset_session = function(session){
    session['host'] = "";
    session['title'] = "";
    session['players'] = {};
    session['dealer']['hand'] = [];
    session['active'] = false;
    session['in-match'] =  false;
    session['capacity'] = 0;
}

/**
 * Get next avail game session
 */
var avail_session = function(){
  for (var i = 0; i <= session_capacity; i++) {
    if(!game_sessions[i]['active']){
      //if game session is avail, return the session key/id
      return i;
    }
  }
  //fail to find an available session, all session busy
  //creating new session
  populate_game_sessions(session_capacity+1,session_capacity + cap_increment);
  var id = session_capacity+1;
  session_capacity += cap_increment;
  return id;
}

/**
 * Create a game session
 */
var create_session = function(id, title, username){
  game_sessions[id]['host'] = username;
  game_sessions[id]['title'] = title;
  game_sessions[id]['turn'] = 'p1';
  game_sessions[id]['active'] = true;
  newDeck(game_sessions[id]);
}

/**
 * Utitlities for player_sessions
 */
/**
 * Create a new user under requested name
 * return true on success, return false on failure
 */
var load_user = function(key, cb){
  player_sessions[key] = {};
  player_sessions[key]['username'] = key;
  // load nickname from DB
  database.getUserInfo(key, function(result){
    player_sessions[key]['nickname'] = result.nickname;
    player_sessions[key]['balance'] = result.balance;
    player_sessions[key]['wins'] = result.wins;
    player_sessions[key]['loses'] = result.loses
    cb(); 
  });
}

var update_nick = function(key, nickname, cb){
  database.setUserNickname(key, nickname, cb());
  player_sessions[key]['nickname'] =  nickname;
}

var update_balance = function(key, balance, cb){
  database.setUserBalance(key, balance, cb());
  player_sessions[key]['balance'] = balance;
}


/***************************************************************************************************
 * Login socket logics
 */
login.on('connection', function(socket){
  console.log(socket.id + ' connected')
  // if has cookies
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie = cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        //add to player list & redirect
        // redirect to lobby
        socket.emit('login success');
      }
    }
  }

  socket.on('login', function(username, password){
    var validate = database.validateUser;
    var result;
    validate(username, password, function(result){
      console.log('result = ' + result);
      if (result){
        // success, load user from DB and emit success msg
        console.log('login success');
        socket.emit('login success');
        
      } else{
        // failed, emit failure msg
        console.log('login failure');
        socket.emit('login failure');
      }
    })
  })

  socket.on('create account', function(username, nickname, password){
    database.addUser(username, password, nickname, function(){
      console.log('login success');
      socket.emit('login success');
    }, function(){
      // failed, emit failure msg
      console.log('login failure');
      socket.emit('login failure');
    })
  })
})

/***************************************************************************************************
 * Lobby socket logics
 */
lobby.on('connection', function(socket){
  //should have credentials
  var username = '';
  console.log(socket.handshake.headers.cookie);
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie = cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        username = socket_cookie['username'];
        console.log("user connected to lobby is '" + username + "'");
        load_user(username, function(){
          console.log('Finished loading users. spamming emits')
          console.log('username = ' + username)
          socket.emit('init', JSON.stringify(player_sessions[username]));
        });  
        // send out game lobby list
        socket.emit('lobby update', JSON.stringify(game_sessions));
        database.getTopUsers(function(result){
          // send out leaderboard
          socket.emit('leaderboard', JSON.stringify(result));
        })
      }else{
        // failed to get cookie
        socket.emit('redirect to login');
      }
    }else{
      // failed to get cookie
      socket.emit('redirect to login');
    }
  }else{
    // failed to get cookie
    socket.emit('redirect to login');
  }

  console.log('connected');

  //requesting a lobby list refresh
  socket.on('refresh', function(){
    socket.emit('lobby update', JSON.stringify(game_sessions));
  })

  //request to create a room
  socket.on('create room', function(title){
    var id = avail_session();
    //Fill metadata
    create_session(id,title,username);
    // send ack, refresh lobby list
    socket.emit('create success', id);
    lobby.emit('lobby update', JSON.stringify(game_sessions));
  })

  //requesting to join a room
  socket.on('join room', function(id){
    //check if room is not full
    if(game_sessions[id]['capacity'] != max_session_capacity){
      //increase capacity
      game_sessions[id]['capacity'] += 1;
      // init metadata
      game_sessions[id]['players'][username] = {};
      game_sessions[id]['players'][username]['username'] = username;
      game_sessions[id]['players'][username]['nickname'] = player_sessions[username]['nickname'];
      game_sessions[id]['players'][username]['hand'] = [];
      game_sessions[id]['players'][username]['chicken dinner'] =  false;
      var p = 'p' + game_sessions[id]['capacity'];
      game_sessions[id][p] = username;
      //console.log("Joining room, current sessions: " + JSON.stringify(game_sessions, null, 2));
      player_sessions[username]['in-game'] = id;      
      //send ack, refresh lobby list
      lobby.emit('lobby update', JSON.stringify(game_sessions));
      socket.emit('join success')
    }else{
      //room is full
      socket.emit('join fail');
    }
  })

  socket.on('disconenct', function(){
    // do something
    console.log('disconnect from lobby by ' + username);
  })
})

/***************************************************************************************************
 * Profile/account socket logics
 */
account.on('connection', function(socket){
  var username = '';
  console.log(socket.handshake.headers.cookie);
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie = cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        username = socket_cookie['username'];
        load_user(username, function(){
          socket.emit('init', JSON.stringify(player_sessions[username]));
          database.getTopUsers(function(result){
            // send out leaderboard
            socket.emit('rankings', JSON.stringify(result));
          })
        });
      }else{
        // failed to get cookie
        socket.emit('redirect to login');
      }
    }else{
      // failed to get cookie
      socket.emit('redirect to login');
    }
  }else{
    // failed to get cookie
    socket.emit('redirect to login');
  }

  // more functionalities?

})

function nextPlayer(session){
  switch(session['turn']){
    case 'p1':
      if(session['match-capacity'] > 1){
        // to player 2
        session['turn'] = 'p2';
      }
      else session['turn'] = 'dealer';
      break;
    case 'p2':
      if(session['match-capacity'] > 2){
        // to player 3
        session['turn'] = 'p3';
      }
      else session['turn'] = 'dealer';
      break;
    case 'p3':
      // to dealer
      session['turn'] = 'dealer';
      break;
    case 'dealer':
      // to o1
      session['turn'] = 'p1';
      break;
  }
}

function dealCard(session){
  // get turn
  var turn = session['turn'];
  // if dealer's
  if(turn === 'dealer'){
    session['dealer']['hand'].push(session['deck'].pop());
  }else{ // if player's
    var username = session[turn];
    session['players'][username]['hand'].push(session['deck'].pop());
  }
}

/**
 * shuffle deck of given game session
 */

var shuffle_deck = function(session){
  session['deck'] = shuffle(session['deck']);
}  

function removeFromGame(session, username){
  console.log(session);
  console.log(username);
  // When capacity = 1
  if(session['capacity'] === 1){
    // reset session
    delete session['players'][username];
    delete session['p1'];
    delete session['deck'];
    reset_session(session)
  }else if(session['capacity'] === 2){
    // 2 players
    if(session['host'] === username){
      // if host is leaving, migrating.
      delete session['players'][username];
      session['host'] = session['p2'];
      session['p1'] = session['p2'];
      session['capacity'] = 1;
      delete session['p2'];
    }else{
      // not host
      delete session['players'][username];
      session['capacity'] = 1;
      delete session['p2'];
    }
  }else if(session['capacity'] === 3){
    // max - 3 players
    if(session['p1'] === username){
      // host leaving
      delete session['players'][username];
      session['host'] = session['p2'];
      session['p1'] = session['p2'];
      session['p2'] = session['p3'];
      session['capacity'] = 2;
      delete session['p3'];
    }else if(session['p2'] === username){
      // p2 leaving
      delete session['players'][username];
      session['p2'] = session['p3'];
      session['capacity'] = 2;
      delete session['p3'];
    }else {
      // p3 leaving
      delete session['players'][username];
      session['capacity'] = 2;
      delete session['p3'];
    }
  }
  // tell lobby to update list
  lobby.emit('lobby update', JSON.stringify(game_sessions));
}

function newDeck(session){
  session['deck'] = JSON.parse(JSON.stringify(cards));
  for (var i = 5; i >= 0; i--) {
    shuffle_deck(session);
  }
}

function checkChickenDinner(session, username, dealer){
  // check if the claim of chicken dinner is true
  var hand = [];
  if(!dealer){
    // check for non dealer
    hand = session['players'][username]['hand'];
  }else{
    // check dealer
    hand = session['dealer']['hand'];
  }
  // check first card
  // check if ACE
  if(hand[0].name === 'ace'){
    // if first card is ace
    // check if 2nd card is 10/J/Q/K
    if((hand[0].name === '10') || (hand[0].name === 'jack') || (hand[0].name === 'king') || (hand[0].name === 'queen')){
      // is chicken dinner
      return true;
    }

  }else if((hand[0].name === '10') || (hand[0].name === 'jack') || (hand[0].name === 'king') || (hand[0].name === 'queen')){
    // first card is 10/J/Q/K
    // check if 2nd card Ace
    if (hand[0].name === 'ace') {
      // is chicken dinner
      return true
    }
  }
  // false claim
  return false;
}

function resetHands(session){
  for(var i = 1; i <= session['capacity']; i++){
    var p = 'p'+i;
    delete session['players'][session[p]]['hand'];
    session['players'][session[p]]['hand'] = [];
    session['players'][session[p]]['chicken dinner'] = false;
  }
}



/***************************************************************************************************
 * Game session logic
 */
game.on('connection', function(socket){
  var username = '';
  var sessionID = -1;
  var session = {};
  var channelname = '';
  // join game channel for broadcast
  if(socket.handshake.headers.cookie){
    console.log('cookies detected. checking cookies');
    var socket_cookie =  cookie.parse(socket.handshake.headers.cookie);
    console.log(socket_cookie);
    if(socket_cookie){
      if (socket_cookie['authorized']) {
        username = socket_cookie['username'];
        sessionID = player_sessions[username]['in-game'];
        session = game_sessions[sessionID];
        channelname = "#" + sessionID;
        socket.join(channelname);
        session['deck'][0]['value'] = 9999999999;
        console.log(session['deck']);
        load_user(username, function(){
          socket.emit('init', JSON.stringify(player_sessions[username]), JSON.stringify(session));
          game.to(channelname).emit('player join', JSON.stringify(session));
        })
      }else{
        //redirect back to login
      }
    }else{
      //redirect back to login
    }
  }else{
    //redirect back to login
  }
  socket.on('disconnect', function(){
    // remove user from game session
    removeFromGame(session, username);
    // do more clean ups
    game.to(channelname).emit('player left', username, JSON.stringify(session));
  })
  
  /**
   * Gameflow:
   * Deck shuffled
   * Place bet & ready
   * distribute cards
   * p1 turn
   * p2 turn
   * p3 turn
   * dealer turn
   */
  /**
   * A turn has:
   * card deal
   * stay/pass
   * split
   */
  ////////////////////// TODO - add something when joining mid match
  // ready to start
  socket.on('ready', function(betAmount){
    session['players'][username]['bet'] = betAmount;
    player_sessions[username]['balance'] -= betAmount;
    database.setUserBalance(username, player_sessions[username]['balance']);
    game.to(channelname).emit('lock in', username, betAmount);
    socket.emit('update balance', player_sessions[username]['balance']);
  });

  // when all bets are placed
  socket.on('card distribution request', function(){
    if(username === session['host']){//only the host can request
      session['match-capacity'] = session['capacity'];
      session['in-match'] = true;
      lobby.emit('lobby update', JSON.stringify(game_sessions));
      // first distribution
      // loop through 2 whole cycles
      for (var i = 0; i < ((session['match-capacity'] + 1) * 2); i++) {
        shuffle_deck(session);
        dealCard(session);
        nextPlayer(session);
      }
      console.log(session);
      // tell all to play card distribution animation
      game.to(channelname).emit('init card distribution', JSON.stringify(session));
    }
  });

  // when card deal is requested
  socket.on('card deal', function(){
    shuffle_deck(session);
    dealCard(session);
    // card dealt, to user, new session info
    game.to(channelname).emit('card dealt', username, JSON.stringify(session));
  })

  // stay/pass
  socket.on('pass', function(){
    nextPlayer(session);
    // next player, new session
    game.to(channelname).emit('next player', JSON.stringify(session));
  })

  socket.on('split', function(){
  // do something for split
  // dunno this yet, have to think about it
  // have to consider 2x Aces scenarios
  })
  
  socket.on('chicken dinner', function(){
    // do sth on chicken dinner
    // check chicken dinner claim
    if(checkChickenDinner(session,username,false)){
      // if claim is true
      session['players'][username]['chicken dinner'] = true;
      // check if dealer also have chicken dinner
      if(checkChickenDinner(session,username,true)){
        // dealer is also ChickenDinner
        game.to(channelname).emit('chicken dinner interrupt');
      }
    }
  })

  socket.on('chicken dinner interrupt', function(){
    // only host can call
    if(username === session['host']){
      // dealer has chicken dinner
      // check chicken dinner for all, chicken = draw, nano = lose
      const players = Object.keys(session['players']);
      for(var player of players){
        // check chicken
        if(checkChickenDinner(session, player, false)){
          // player has chicken dinner, draw
          game.to(channelname).emit('draw', player);
          // refund bet
          player_sessions[player]['balance'] += session['players'][player]['bet'];
          session['players'][player]['bet'] = 0;
          database.setUserBalance(player, player_sessions[player]['balance']);
        }



        game.to(channelname).emit('lose', player);
        database.updateStats(player, false);
        player_sessions[player]['loses'] += 1;
        session['players'][player]['bet'] = 0;
      }
      // reset hands, decks, and flags post game
      resetHands(session);
      newDeck(session);
      session['mid-match'] = false;
      socket.emit('init', JSON.stringify(player_sessions[username]), JSON.stringify(session));
      lobby.emit('lobby update', JSON.stringify(game_sessions));
    }
  })



  // game end, total up
  socket.on('tally score', function(){
    if(username === session['host']){
      // only host can request a tally
      // check if dealer has chicken dinner
      if(!checkChickenDinner(session,username,true)){
        // dealer doesn't have chicken dinner
        // dealer's turn
        // add dealer logics here
        var dealer = session['dealer'];
        var score = calculateHandWithAces(dealer['hand']);
        // if score is less than 17
        while(score < 17){
          // turn for be dealer's at this point, printing just in case
          console.log(session['turn']);
          // draw another card
          shuffle_deck(session);
          dealCard(session);
          // calc score again
          score = calculateHandWithAces(dealer['hand']);
          session['dealer']['score'] = score;
        }
        // done dealer's draws, emitting update
        game.to(channelname).emit('dealer drawn', JSON.stringify(session));
        // tally up players' hand
        const players = Object.keys(session['players']);
        for(var player of players){
          if(!session['players'][player]['chicken dinner']){
            // only if not chicken dinner
            var score = calculateHandWithAces(session['players'][player]['hand']);
            session['players'][player]['score'] = score;
          }          
        }
        // check if dealer is busted
        var dealer_busted = false;
        if(score > 21) dealer_busted = true;
        // check against dealer score
        for(var player of players){
          // check if chicken dinner
          if(!session['players'][player]['chicken dinner']){
            // if not chicken dinner
            if(!dealer_busted){
              // dealer not busted, continue as normal
              // declare victory/defeat (spam emit on channel)
              if((session['players'][player]['score'] < session['dealer']['score'])||(session['players'][player]['score'] > 21)){
                // lost
                game.to(channelname).emit('lose', player);
                database.updateStats(player, false);
                player_sessions[player]['loses'] += 1;
                session['players'][player]['bet'] = 0;
              }else if (session['players'][player]['score'] === session['dealer']['score']){
                // draw
                game.to(channelname).emit('draw', player);
                // refund bet
                player_sessions[player]['balance'] += session['players'][player]['bet'];
                session['players'][player]['bet'] = 0;
                database.setUserBalance(player, player_sessions[player]['balance']);
              }else{
                // win
                game.to(channelname).emit('win', player);
                database.updateStats(player, true);
                player_sessions[player]['wins'] += 1;
                session['players'][player]['bet'] = 0;
                // payout
                player_sessions[player]['balance'] += session['players'][player]['bet'] * 2;
                database.setUserBalance(player, player_sessions[player]['balance']);
              }
            }else{
              // dealer is busted
              // auto win unless busted
              if(session['players'][player]['score'] > 21){
                // busted, draw
                game.to(channelname).emit('draw', player);
                // refund bet
                player_sessions[player]['balance'] += session['players'][player]['bet'];
                session['players'][player]['bet'] = 0;
                database.setUserBalance(player, player_sessions[player]['balance']);
              }else{
                // auto win
                game.to(channelname).emit('win', player);
                database.updateStats(player, true);
                player_sessions[player]['wins'] += 1;
                session['players'][player]['bet'] = 0;
                // payout
                player_sessions[player]['balance'] += session['players'][player]['bet'] * 2;
                database.setUserBalance(player, player_sessions[player]['balance']);
              }
            }
          }else{
            // is chicken dinner, arrive here if dealer != chicken dinner
            // win 2x
            game.to(channelname).emit('win', player);
            database.updateStats(player, true);
            player_sessions[player]['wins'] += 1;
            session['players'][player]['bet'] = 0;
            // payout
            player_sessions[player]['balance'] += session['players'][player]['bet'] * 3;
            database.setUserBalance(player, player_sessions[player]['balance']);
          }
        }
      }else{
        // dealer has chicken dinner
        // will arrive here if and only if dealer has chicken dinner && 0 player has chicken dinner
        // everyone lost, doom to the people
        const players = Object.keys(session['players']);
        for(var player of players){
          game.to(channelname).emit('lose', player);
          database.updateStats(player, false);
          player_sessions[player]['loses'] += 1;
          session['players'][player]['bet'] = 0;
        }
      }
      // reset hands, decks, and flags post game
      resetHands(session);
      newDeck(session);
      session['mid-match'] = false;
      socket.emit('init', JSON.stringify(player_sessions[username]), JSON.stringify(session));
      lobby.emit('lobby update', JSON.stringify(game_sessions));
    }
  });
})

// not needed, probably
io.on('connection', function(socket){
  // On new socket connection
  socket.on('disconenct', function(){

  })
})

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);


/**
 * calculateHandTotals
 *
 * calculates the the total value fo a hand: need ace logic
 *
 * */

function calculateHandTotals(hand) {
    let sum = 0;

    for (let i = 0; i < hand.length; i++) {
        sum += hand[i].value;
    }
    return sum;
}

/**
 * Returns boolean value if the hand contains an ace
 * @param hand
 * @returns {boolean}
 */

function hasUnreducedAce(hand) {

    for (let i = 0; i < hand.length; i++) {
        if ((hand[i].name === "ace") && (hand[i].value === 11)) {
            return true;
        } else {
            return false;
        }
    }
}

/**
 * finds the aces in the hand that has not already been reduced and sets its value to 1
 *
 * @param hand
 *
 */
function calculateHandWithAces(hand) {
    let total = calculateHandTotals(hand);

    while (hasUnreducedAce(hand) && total > 21) {
        for (let i = 0; i < hand.length; i++) {
            if (hand[i].name === "ace" && hand[i].value === 11) {
                hand[i].value = 1;

               break;
            }
        }
    total = calculateHandTotals(hand);
    }
}

/**
 * Generate random alphanumeric
 */
function randomString(length){
  var text = "";
  var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (var i = 0; i < length; i++) 
    text += possible.charAt(Math.floor(Math.random()*possible.length));
  return text;
}

/** Fisher-Yates shuffle algorithm
 * Shuffles array in place.
 * @param {Array} a items An array containing the items.
 */
function shuffle(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
